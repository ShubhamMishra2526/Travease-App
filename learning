// const fs = require('fs');
// const express = require('express');
// const morgan = require('morgan');

// const tourRouter = require('./routes/tourRoutes');
// const userRouter = require('./routes/userRoutes');

// const app = express();
// // 1) MIDDLEWARES

// app.use(morgan('dev'));
// // morgan is a middleware which is used to log the request and response in the console and is third party middleware

// //including middleware
// //------------------------------------------------------------
// app.use(express.json());

// // crating our own middleware
// // this middleware will be used to log the request and response
// // this middleware will be always run in response request cycle as no specific route middleware is defined
// // .use() method put the middleware in the middleware stack

// app.use((req, res, next) => {
//   console.log('Hello from the middleware');
//   next();
// });

// app.use((req, res, next) => {
//   req.requestTime = new Date().toISOString();
//   next();
// });

// // so every middleware has access to the request and response object and every middleware which is present in the stack will
// // be executed before the final response is sent and if any middleware defines any method or property on the request then it can be used in the cycle anywhere.

// //------------------------------------------------------------

// // app.get('/', (req, res) => {
// //   res
// //     .status(200)
// //     .json({ message: 'Hello from the server side!', app: 'Natours' });
// // });

// // app.post('/', (req, res) => {
// //   res.send('You can post to this endpoint...');
// // });

// // 2) ROUTES HANDLERS
// //------------------------------------------------------------

// const tours = JSON.parse(
//   fs.readFileSync(`${__dirname}/dev-data/data/tours-simple.json`)
// );

// //route handler for a get request so that we can get the tours
// //------------------------------------------------------------
// // specified the version so that any user with previous version dont face any difficulty if we make some changes
// // app is express object which will do all the work as a server
// // we are sending the response in Jsend format as it contains the status of the response and the data
// // const getAllTours = (req, res) => {
// //   console.log(req.requestTime);
// //   res.status(200).json({
// //     status: 'success',
// //     requestedAt: req.requestTime,
// //     results: tours.length,
// //     data: {
// //       tours,
// //     },
// //   });
// // };
// // // req.params is where all the variables and parameters are defined are stored
// // // (:variable_name) is used to define a variable and now id below is a variable where the value corresponding to it is save
// // // (:variable_name?) is used to define an optional parameter

// // const getTour = (req, res) => {
// //   console.log(req.params);

// //   const id = req.params.id * 1; // trick to convert string digit to a number
// //   // find method will create an array which will only contain the element satisfying the condition
// //   const tour = tours.find((el) => el.id === id);

// //   //   if (id > tours.length) {
// //   if (!tour) {
// //     return res.status(404).json({
// //       status: 'fail',
// //       message: 'invalid id!',
// //     });
// //   }

// //   res.status(200).json({
// //     status: 'success',
// //     // results: tours.length,
// //     data: {
// //       tour,
// //     },
// //   });
// // };

// // //------------------------------------------------------------

// // //route handler for a post request so that we can create new tour
// // //------------------------------------------------------------
// // // on the client side the req is sent with some data and then we send some appropriate responses monitoring that data
// // // but express does not put the body data in the req so we need to make the use middlewares
// // // a middleware basically a step in b/w that modifies the incoming data

// // const createTour = (req, res) => {
// //   //   console.log(req.body);

// //   const newId = tours[tours.length - 1].id + 1;
// //   const newTour = Object.assign({ id: newId }, req.body);

// //   tours.push(newTour);
// //   fs.writeFile(
// //     `${__dirname}/dev-data/data/tours-simple.json`,
// //     JSON.stringify(tours),
// //     (err) => {
// //       res.status(201).json({
// //         status: 'success',
// //         data: {
// //           tour: newTour,
// //         },
// //       });
// //     }
// //   );
// // };
// // //route handler for a put request so that we can update the tours
// // //------------------------------------------------------------
// // const updateTour = (req, res) => {
// //   //   if (id > tours.length) {
// //   if (req.params.id * 1 > tours.length) {
// //     return res.status(404).json({
// //       status: 'fail',
// //       message: 'invalid id!',
// //     });
// //   }
// //   res.status(200).json({
// //     status: 'success',
// //     data: {
// //       tour: '<Updated tour here>',
// //     },
// //   });
// // };

// // //route handler for a delete request so that we can delete the tours
// // //------------------------------------------------------------

// // const deleteTour = (req, res) => {
// //   //   if (id > tours.length) {
// //   if (req.params.id * 1 > tours.length) {
// //     return res.status(404).json({
// //       status: 'fail',
// //       message: 'invalid id!',
// //     });
// //   }
// //   res.status(204).json({
// //     status: 'success',
// //     data: null,
// //   });
// // };

// const getAllusers = (req, res) => {
//   res.status(500).json({
//     status: 'error',
//     message: 'This route is not yet defined!',
//   });
// };
// const getUser = (req, res) => {
//   res.status(500).json({
//     status: 'error',
//     message: 'This route is not yet defined!',
//   });
// };
// const createUser = (req, res) => {
//   res.status(500).json({
//     status: 'error',
//     message: 'This route is not yet defined!',
//   });
// };
// const deleteUser = (req, res) => {
//   res.status(500).json({
//     status: 'error',
//     message: 'This route is not yet defined!',
//   });
// };
// const updateUser = (req, res) => {
//   res.status(500).json({
//     status: 'error',
//     message: 'This route is not yet defined!',
//   });
// };

// // app.get('/api/v1/tours',getAllTours);
// // app.get('/api/v1/tours/:id',getTour);
// // app.post('/api/v1/tours',createTour);
// // app.patch('/api/v1/tours/:id', updateTour);
// // app.delete('/api/v1/tours/:id',deleteTour);

// // -------------------------------------------------------------

// // now if we want to change the version of the api or the resource name we need to manually change it so to make it easy we do below

// // 3) ROUTES
// //------------------------------------------------------------

// // separating the routes for the users and tours so that we can easily manage the routes and if we want to add any new route then we can do it easily
// const tourRouter = express.Router();
// const userRouter = express.Router();
// // tourRouter is a router object which is used to define the routes for the tours and is middleware function

// // For tours
// tourRouter.route('/').get(getAllTours).post(createTour);

// tourRouter.route('/:id').get(getTour).patch(updateTour).delete(deleteTour);
// // -------------------------------------------------------------

// // For users
// userRouter.route('/').get(getAllusers).post(createUser);

// userRouter.route('/:id').get(getUser).patch(updateUser).delete(deleteUser);

// app.use('/api/v1/tours', tourRouter);
// app.use('/api/v1/users', userRouter);
// // basically we are creating a new router object and then we are using it in the app object and a sub application kind of thing

// // 4) SERVER
// //------------------------------------------------------------

// const port = 3000;
// app.listen(port, () => {
//   console.log(`App running on port ${port}..`);
// });

// Separation of files were deone to make the code more readable and manageable
//-------------------------------------------------------------

// // Param middleware
//-------------------------------------------------------------
// // this middleware will be stacked only for a url containing a specific parameter mentioned

// router.param('id),(req,res,next,val) => {
// console.log(`Tour id is: ${val}`);
//     next();
// };)
//-------------------------------------------------------------
// express.static() is a built-in middleware function in Express. It serves static files and is based on serve-static. It can take a path as an argument and will serve the files in that directory. The path can be absolute or relative to the current working directory. The path can also be a URL.
// app.use(express.static(`${__dirname}/public`));
// requiring dotenv for getting access of env variables and also config its path so that it reads and stores the env variables in the node env
//-------------------------------------------------------------

// current environment
// env variables are global variables that are used to define the environment in which the node app is running
// console.log(app.get('env'));
// node js also sets a lot of env variables present in the process core module which is present available we dont even need to require it
// console.log(process.env);

// const tourSchema = new mongoose.Schema({
//   name: {
//     type: String,
//     required: [true, 'A tour must have a name'],
//     unique: true,
//   },
//   rating: {
//     type: Number,
//     default: 4.5,
//   },
//   price: {
//     type: Number,
//     required: [true, 'A tour must have a price'],
//   },
// });

// // we use first letter capital for model names
// const Tour = mongoose.model('Tour', tourSchema);

// const testTour = new Tour({
//   name: 'The Park Camper',
//   // rating: 4.7,
//   price: 997,
// });

// // this will save testTour in the tour collection of the database
// testTour
//   .save()
//   .then((doc) => {
//     console.log(doc);
//   })
//   .catch((err) => {
//     console.log('ERROR :', err);
//   });

// const tours = JSON.parse(
//   fs.readFileSync(`${__dirname}/../dev-data/data/tours-simple.json`)
// );

// create a middleware function to check the id
// this function will be called before the getTour function
// and it will check if the id is valid or not
// this function will be called for all the requests
// and it will check if the id is valid or not

// const checkID = (req, res, next, val) => {
//   console.log(`Tour id is: ${val}`);
//   if (req.params.id * 1 > tours.length) {
//     return res.status(404).json({
//       status: 'fail',
//       message: 'invalid id!',
//     });
//   }
//   next();
// };

// const checkBody = (req, res, next) => {
//   if (!req.body.name || !req.body.price) {
//     return res.status(400).json({
//       status: 'fail',
//       message: 'missing name or price',
//     });
//   }
//   next();
// };

// // API in route handler
// BUILD THE QUERY
//------------------
// creating a copy ofn the req.query as we need to exclude some special queries like page for pagination
// we use ...(destructuring) so as to create the hard copy o/w the req.query will also change if we try to change the shallow copy

// FILTERING-----
//------------------
// const queryObj = { ...req.query };
// const excludeFields = ['page', 'sort', 'limit', 'fields'];

// // .forEach as we dont want any array we just need to traverse and delete the excludedFields
// excludeFields.forEach((el) => delete queryObj[el]);

// // console.log(req.query, queryObj);
// // find is used for finding and returning all of the documents

// // const tours = await Tour.find(queryObj);
// // now the above Tour.find() returns a query so using await lets the query to execute and comeback with the documents that matches our query so there is now way of implementing sorting or pagination
// // so we save the part in the query and then chain all the methods to the query that we need to only then we await the query

// // ADVANCED FILTERING----------
// //-----------------------------
// let queryStr = JSON.stringify(queryObj);
// queryStr = queryStr.replace(/\b(gte|gt|lte|lt)\b/g, (match) => `$${match}`);

// // filter object for the query for greater than equal ==> {difficulty: 'easy', duration: {$gte : 5}}
// // $ is mongoDb operator sign

// let query = Tour.find(JSON.parse(queryStr));

// SORTING
//------------------
// if (req.query.sort) {
//   const sortBy = req.query.sort.split(',').join(' ');
//   query = query.sort(sortBy);
//   // if there is a tie so we sort acc to a diffirent criteria
//   // sort('price ratingsAverage')
// } else {
//   query = query.sort('price');
// }

// LIMITING THE FIELDS A CLIENT CAN REQUEST
//-----------------------------------------------

// if (req.query.fields) {
//   const fields = req.query.fields.split(',').join(' ');
//   query = query.select(fields);
//   // if there is a tie so we sort acc to a diffirent criteria
//   // sort('price ratingsAverage')
// } else {
//   query = query.select('-__v'); // for excluding __v
// }

// PAGINATION
//----------------------------------------
// ?page=2&limit=10

// const page = req.query.page * 1 || 1;
// const lim = req.query.limit * 1 || 100;
// const sk = (page - 1) * lim;
// query = query.skip(sk).limit(lim);

// if (req.query.page) {
//   const numTours = await Tour.countDocuments();
//   if (sk >= numTours) throw new Error('This page does not exist');
// }

// const tours = await Tour.find()
//   .where('duration')
//   .equals(5)
//   .where('difficulty')
//   .equals('easy');

// Middlewares in mongoose : there are four types of middlewares: Query, aggregate, Document, Model

// Data validation and sanitization
//-------------------------------------

// mongoose comes with a lot of built-in-validators that we can use to validate the data before saving it to the database
// custom validators can be created by using the validate property in the schema

// There are libraries of npm of data validation and sanitization like express-validator, validator.js(library of string validators and sanitizers)

//____________________________________________

// Error handling
//____________________________________________
// DEBUGGING Node.js with NDB
// npm i ndb --global

// fixing the error handling in the uncatched errors we dont want html kind of response

// Production and development environment error handling

// Marking the invalid db errors to operational and also some meaningfull message
// .1 invalid id type
// .2 Duplicate key error
// .3 Invalid rating average
// .4 Invalid difficulty

//_________________________________________________________________________________-
// JWT (Json web token) is a stateless solution for the authentication
// Best for REST ful api as they should always be stateless
// It is basically a unique string which is send to the client and stored in its local storage
// it consists of header which has meta data, Payload which has a unque id and verify signature which has a
// secret code which combines to become a JWT and then it is sent to the client and is then verified using
// matching orignal and the generated signal with the incoming JWT and then authentication is granted is done

// Authorisation
// Giving permissions for performing a certain task
//_________________________________________________________________________________-

// Password reset functionality

// user sends a post req for the forget password route with his email
// And this will then create a reset token and send that to the email address that was provided
// User then send the token with the new password from his email in order to update his password

// setting up the email.js

// can use gmail as a transporter
// const transporter = nodemailer.createTransport({
//     service: 'Gmail',
//     auth: {
//       user: process.env.EMAIL_USERNAME,
//       pass: process.env.EMAIL_PASSWORD,
//     },
//     // Activate in gmail "less secure app" option
//   });
// But gmail is not a good option for production based app as it allows only 500 emails per day and will mark you as spammer
// So better use sendgrit and mailgun

// Updating the current user password
// Updating the current user allowed fields data
// Deleting the current user i.e making the user inactive

// sending token using cookie
// cookie is basically a small piece of text that a server can send to a client and it will automatically store it and will send it back with all the future request to the same server

//_____________________________________________
// Rate limiting for preventing the brute force attacks from the same IP
// Using express-rate-limit package

//_______________________________________________
// implementing sending security headers
// using helmet

//_______________________________________________
// DATA SANITIZATION
// Cleaning all the data thatb comes in to the application from malicious code
//
//_______________________________________________
// MODELLING A DB
// 1 Geospatial locations to be saved in the tour model wih the coordinates and the address
// 2 We create the embedded and then referenced guides array for the tour referenced to the USer
// 3 Populating tour guides in order to get access of the referenced tour guides result of which shows that the data was embedded but in real it was not

//_______________________________________________
// MAINTAINING REVIEWS
// Made review model
// Made review controller and reviewroutes
// populated the tour and user data in the reviews
//_______________________________________________
// VIRTUAL POPULATE
// Now how to populate tour with the reviews?
// As we were only doing parent referencing of the reviews so we can do child referencing but this is a bad practice
// Sol:---> virtual populate helps to show the reviews for a specific tour without storing the review ids in the tour

//_______________________________________________
// FACTORY FUNCTION
// Helps to create a fucntion which return a fucntions and avoids repetition of code in controller fucntions
// basically we streamlined all the handler fucntions in a single factory handler as it reduces the code redundancy

//________________________________________________
// INDEXES
// Now getting all the tours by some filter will examine all the tours and then return us the result
// this will take a lot of time in execution so we will use indexing
// so we can set our own indexes for the query that we mostly query for
//________________________________________________
// MAKING REVIEW RATING STATS WORK
//________________________________________________
// RESTRICTING THE USER TO POST ONE REVIEW PER TOUR
//________________________________________________
// SERVER SIDE RENDERING USING PUG TEMPLATES WHICH WILL FILL OUR DATA IN THE TEMPLATES
//________________________________________________
// PUG
// h1 The Park Camper // equivalent to the <h1> The Park Camper </h1>
//-   h1= tour
//-   h2= user.toUpperCase()

//-   //- h1 The Park Camper -- This is how we make a comment in the pug
//-   - const x = 9; //- This is know as interpolation where we define a variable as like in js and use that here and it wont show up a html
//-   h2= 2*x
//-   p This is just some text!
// We can also use js in PUG using interpolation
// We can use the variable which was passed to render the route in the pug
// We can use mixin for removing repetitive code from the pug
// We first created a base pug so that it can be extended to every othe template as sme parts in every page has same kind of strcuture
// We then created overview page then tour page and then login page pug templates
// We can also include a pug template into the other same we did for the header and footer
// By blocking some part of the pug template we can
//________________________________________________

// We made login.js in which we used axios which is a promise-based HTTP client for the browser and Node.js. It is used primarily to make HTTP requests (like GET, POST, PUT, DELETE) from your frontend (JavaScript in the browser) or backend (Node.js).
// I explicitly made a axios.map.js file to avail this as my CSP of the browser was blocking the external source
// Finally we installed axios in node and then we imported it and removed the script of axios
// Js in frontend does not work with require its only possible in express and node so we are using import
//________________________________________________
// We use mapbox for the map view of the location of the tour in the tour page
//________________________________________________
// Then we installed a parcel-bundler which will look for all the js files and bundle the code together and will serve us in bundle.js file
// For above we need to mention explicitly in the package.json file
// In this we made all the js files connected to the single index.js file so that it can be accesed and copied to the bundle.js output file
//________________________________________________
// Implementng Log out feature
// Now as we mentioned in createAndSendToken in authController that httpOnly as true so that our cookies can not be deleted and modified in the browser
// So for logging out we cant delete the cookie by code but we can create a new logout route which can simply send a new cookie with a exact same name but without a token
//________________________________________________
// Implemented the User account page and also the update password and the name and email routes
//________________________________________________
// Uploading user photo using multer which handles multipart form data which is a form encoding that is used to upload files from a form
// We will allow the user to upload the photo in update me route
//________________________________________________
// We will try to the resize the image usign sharp npm package
// and will run the middleware just before the updateMe
// Also earlier we were directly saving the images in the disk but on using sharp we will first resize it and the save it to the specified path
//________________________________________________
// Then we created a fucntion to upload the cover image and the tout images for the tours using upload.fields and specified the fields to be uploaded on
// Then we resized the images and uploaded them to the specified fields
